# 最短経路問題

ss14では重み付きの有向グラフのみを考えるものとする。
また基本的には`単一始点最短路問題`を考えるものとする。

`単一始点最短路問題`とは有向グラフ $G = (V,E)$ 上の1点(始点) $s \in V$ が与えられて $s$ から各点 $v \in V$ へ至る最短経路を求める問題として定義される。

## 負辺と負閉路

負の重みを持つ辺を`負辺`という。

負の重みを持つ辺はその辺を通ることでコストの削減につながる"ボーナス"が得られる経路と考えることができる。
長さが負の閉路を`負閉路`という。
この`負閉路`は同じ閉路を何周もすることでコストをいくらでも小さくすることが可能になってしまうため注意が必要である。

負閉路がある場合の例: 一周するごとに-4コストを減らすことが可能である
```mermaid
graph LR
    0(0)--"3"-->1(1)--"9"-->4(4)
    1--"-10"-->2(2)--"2"-->3(3)--"4"-->1
```

トポロジカルソートが可能なグラフであるDAGではどの辺から緩和して行けばよいかが自明であるためである。(動的計画法)
しかし、閉路を持つグラフではどの辺から順番に緩和を行っていけば良いかわ自明ではない。

### 緩和

暫定値`a`を次の候補`b`と比較して`a > b`なら `a = b`とする。C++のtemplate関数では以下のように実装できる。

```C++
template<class T> bool chmin(T& a, T b) {
    if(a > b) {
        a = b;
        return true;
    }
    else return false;
}
```

Rustでは以下のように書ける(`T`に対してトレイト境界`std::cmp::PartialOrd`が必要)

```Rust
fn chmin<T>(a: &mut T, b: T) -> bool 
where T: std::cmp::PartialOrd 
{
    if *a > b {
        *a = b;
        true
    } else {
        false
    }
}
```
始点 $s$ から 各頂点 $v$ への最短経路の値を d[v]で管理し、各辺に対して緩和を繰り返していく。 

$$
d[v] =
\begin{cases}
\infty && (v \ne s) \\
0 && ( v = s )
\end{cases}
$$

辺 $e = (u,v)$ に対する緩和は

$$
\text{chmin}(d[v], d[u] + l(e))
$$

でdの値を更新していく。

d[v] = 100と d[u] + 5 = 3 + 5 = 8を比較して小さい方の8を選ぶ
```mermaid
graph LR
0((u:3))--"5"-->1((v:100))
```
```mermaid
graph LR
2((u:3))--"5"-->3((v:8))
```

d[v] = 6と d[u] + 5 = 3 + 5 = 8を比較して小さい方の6を選ぶ
```mermaid
graph LR
0((u:3))--"5"-->1((v:6))
```
```mermaid
graph LR
2((u:3))--"5"-->3((v:6))
```

## DAG上の最短経路問題: 動的計画法

グラフがDAGでグラフ全体をトポロジカルソートすることで、緩和すべき辺の順序が明らかとなる。
このトポロジカルソートで得られた順番で各辺を緩和していけば各頂点における最短経路を求めることができる。

## ベルマン・フォード法

`ベルマン・フォード法`では、もし始点 $s$ から到達可能な負閉路が存在するならば、その旨を報告し、負閉路が存在しないならば各頂点 $v$ への最短経路を求めるアルゴリズムで、
辺の重みが負の場合でも適用が可能である。

### ベルマンフォード法のアイディア

DAGでない場合ではどの順番に各辺の緩和処理を行っていけばよいか(辺緩和順序)が分からない。
そこで、各辺に対して緩和を行う処理を現在の最短経路の推定値 $d[v]$ が更新されなくなるまで反復することを考える。
実は、 $|V| - 1$ 回の反復によって $d[v]$ は真の最短経路に収束し、 $|V|$ 回目の反復では $d[v]$ は更新されないことを示すことが可能である。
また、逆に始点 $s$ から到達可能な負閉路を持つならば $|V|$ 回目の反復でもある辺 $e = (u,v)$ が存在して、辺 $e$ に対する緩和によって $d[v]$ の値が更新されることを示すことも可能である。

時間計算量は各辺の緩和に $O(|E|)$ の時間計算量を要し、それぞれ $|V|$ 回反復するため $O(|V||E|)$ となる。 

### 正当性

負閉路が存在しない場合では、最短経路はパスであることをすなわち"一筆書き"であることを要求しても良い。
このとき、最短経路に含まれる辺は高々 $|V| - 1$ 本である。
そのため、各頂点に対する緩和を行うと一回のループで少なくとも一頂点への最短距離が求まるため、これを $|V| - 1$ 回繰り返せば各頂点への最短距離が求まる。

また、始点 $s$ から到達可能な負閉路を $P$ として、この $P$ を構成する各頂点 $v_0,v_1, ..., v_{k-1},v_k = v_0$ としたとき、 
$P$ に含まれるすべての辺について更新が行われなかったと仮定すると、 辺 $(v_{i},v_{i+1})$に対する緩和は

$$
d[v_{i+1}] = \min(d[v_i] + l((v_i, v_{i+1})), d[v_{i + 1}])
$$

で行われ、更新が行われないため

$$
\begin{align*}
&d[v_{i + 1}] > d[v_i] + l((v_i, v_{i+1})) \\
&d[v_{i + 1}] - d[v_i] > l((v_i, v_{i+1}))
\end{align*}
$$

よって

$$
\begin{align*}
l(P) &= \sum_{i=0}^{k-1} l((v_i, v_{i+1}))\\
     &\ge \sum_{i=0}^{k-1}(d[v_{i+1}] - d[v_i])\\ 
     &= 0  
\end{align*}
$$

これは $P$ が負閉路であることと矛盾する。よって $|V|$ 回目の反復時には必ず更新が発生する。


<!-- ダイクストラはまだドラフト -->
## ダイクストラ法

ダイクストラ法には単純な実装で時間計算量が $O(|V|^2)$ なものとヒープを用いる時間計算量が $O(|E|log|V|)$ のものが存在する。 

ダイクストラ法が適用できるのはDAGでないグラフのうち辺の重みがすべて正であるものに限られる。

ダイクストラ法は以下の操作を繰り返す


0. まず開始点 $s$ に対して $d[s] = 0, S = \{s\}$と初期化する。ここで $d[v]$ は $v$ への距離で $S$ は最短経路が確定している頂点の集合である。 
1. まだ $S$ に含まれていない頂点 $v$ のうち $d[v]$ の値が最小ものを選ぶ。(実は、この選ばれた頂点 $v$ に対する $d[v]$ はすでに最小値 $d^{\ast}[v]$ になっている)
2. この頂点 $v$ を $S$ に挿入して、その頂点を始点とする辺の緩和を行う。
3. この操作を頂点がすべて $S$ に挿入されるまで反復する

### 正当性

ダイクストラ法の正当性を数学的帰納法で示すことができる。
まず、使用済みでない頂点のうち $d[v]$ が最小となるような頂点 $v$ において 

$$
d[v] = d^{\ast}[v]
$$ 

となって真の最小値となっていることを示す。

すべての使用済みの頂点 $u$ に対して $d[u] = d^{\ast}[u]$ が成立していると仮定して、
使用済みでない頂点 $v$ のうち最小なものを選ぶと $d[v] = d^{\ast}[v]$ となることを示す。

始点 $s$ から頂点 $v$ への最短経路のうち一つを $P$ とする。 $P$ において $v$ の直前の頂点 $u$ とする。

i) 頂点 $u$ が使用済みのとき

帰納法の仮定から 

$$
d[u] = d^{\ast}[u]
$$ 

が成立する。このとき、辺 $e = (u,v)$ についての緩和を行われるため

<!-- ?? -->
$$
d[v] \le d^{\ast}[u] + l(e) = d^{\ast}[v]
$$

よって $d[v] = d^{\ast}[v]$ が成立

ii) 頂点 $u$ が使用済みでないとき

経路 $P$ において $s$ から順にたどって最初の使用済みでない頂点を $x$ とすると先程の議論と同様に

$$
d[x] = d^{\ast}[x]
$$


<!-- フロイド・ワーシャル法まだドラフト -->
## フロイド・ワーシャル法

テーブルの設定:

```C++
dp[k][i][j] // 0,1,2,..,k-1のみの頂点を経由して頂点iから頂点jに至る場合の距離
```

初期条件:

$$
d[0][i][j] = 
\begin{cases}
0 && (i = j) \\
l(e) && (e = (i,j)が存在する) \\
\infty && (それ以外)
\end{cases}
$$

更新:

$$
dp[k + 1][i][j] = \min(dp[k][i][j], dp[k][i][k] + dp[k][k][j])
$$

```mermaid
graph LR
1(i) --"dp[k][i][j]"--> 2(j)
1 --"dp[k][i][k]"--> 3(k) --"dp[k][k][j]"--> 2(j)
```

<!-- ポテンシャルはまだドラフト -->
## ポテンシャル
