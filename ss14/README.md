<!-- ss14はまだドラフト -->
# 最短経路問題

ss14では重み付きの有向グラフのみを考えるものとする。
また基本的には`単一始点最短路問題`を考えるものとする。

`単一始点最短路問題`とは有向グラフ $G = (V,E)$ 上の1点(始点) $s \in V$ が与えられて $s$ から各点 $v \in V$ へ至る最短経路を求める問題として定義される。

## 負辺と負閉路

負の重みを持つ辺を`負辺`という。

負の重みを持つ辺はその辺を通ることでコストの削減につながる"ボーナス"が得られる経路と考えることができる。
長さが負の閉路を`負閉路`という。
この`負閉路`は同じ閉路を何周もすることでコストをいくらでも小さくすることが可能になってしまうため注意が必要である。

負閉路がある場合の例: 一周するごとに-4コストを減らすことが可能である
```mermaid
graph LR
    0(0)--"3"-->1(1)--"9"-->4(4)
    1--"-10"-->2(2)--"2"-->3(3)--"4"-->1
```

トポロジカルソートが可能なグラフであるDAGではどの辺から緩和して行けばよいかが自明であるためである。(動的計画法)
しかし、閉路を持つグラフではどの辺から順番に緩和を行っていけば良いかわ自明ではない。

### 緩和

暫定値`a`を次の候補`b`と比較して`a > b`なら `a = b`とする。C++のtemplate関数では以下のように実装できる。

```C++
template<class T> bool chmin(T& a, T b) {
    if(a > b) {
        a = b;
        return true;
    }
    else return false;
}
```

Rustでは以下のように書ける(`T`に対してトレイト境界`std::cmp::PartialOrd`が必要)

```Rust
fn chmin<T>(a: &mut T, b: T) -> bool 
where T: std::cmp::PartialOrd 
{
    if *a > b {
        *a = b;
        true
    } else {
        false
    }
}
```
始点 $s$ から 各頂点 $v$ への最短経路の値を d[v]で管理し、各辺に対して緩和を繰り返していく。 

$$
d[v] =
\begin{cases}
\infty && (v \ne s) \\
0 && ( v = s )
\end{cases}
$$

辺 $e = (u,v)$ に対する緩和は

$$
chmin(d[v], d[u] + l(e))
$$

でdの値を更新していく。

d[v] = 100と d[u] + 5 = 3 + 5 = 8を比較して小さい方の8を選ぶ
```mermaid
graph LR
0((u:3))--"5"-->1((v:100))
```
```mermaid
graph LR
2((u:3))--"5"-->3((v:8))
```

d[v] = 6と d[u] + 5 = 3 + 5 = 8を比較して小さい方の6を選ぶ
```mermaid
graph LR
0((u:3))--"5"-->1((v:6))
```
```mermaid
graph LR
2((u:3))--"5"-->3((v:6))
```

## ベルマン・フォード法

辺の重みが負でも使える

正当性:

負閉路が存在しない場合では、最短経路はパスであることをすなわち"一筆書き"であることを要求しても良い。
このとき、最短経路に含まれる頂点数は高々 $|V| - 1$ である。
そのため、各頂点に対する緩和を行うと一回のループで少なくとも一頂点への最短距離が求まるため、これを $|V| - 1$ 回繰り返せば各頂点への最短距離が求まる。

## ダイクストラ法

辺の重みが正のときのみ使える
